<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Terminal++: Terminal++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Terminal++
   &#160;<span id="projectnumber">2.0.2</span>
   </div>
   <div id="projectbrief">A C++ library for interacting with ANSI terminal windows</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Terminal++ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://kazdragon.github.io/terminalpp/"><object type="image/svg+xml" data="https://img.shields.io/badge/code-documented-brightgreen.svg?style=flat" style="pointer-events: none;">Documentation</object></a> <a href="https://en.wikipedia.org/wiki/MIT_License"><object type="image/svg+xml" data="https://img.shields.io/github/license/KazDragon/terminalpp.svg" style="pointer-events: none;">License</object></a> <a href="https://ci.appveyor.com/project/KazDragon/terminalpp/branch/master"><img src="https://ci.appveyor.com/api/projects/status/ywpx7m37e902hdoy/branch/master?svg=true" alt="MSVC Build status" class="inline"/></a> <a href="https://github.com/KazDragon/terminalpp/actions?query=event%3Apush"><object type="image/svg+xml" data="https://github.com/KazDragon/terminalpp/workflows/build/badge.svg" style="pointer-events: none;">Linux Build status</object></a> <a href="https://coveralls.io/github/KazDragon/terminalpp?branch=master"><object type="image/svg+xml" data="https://coveralls.io/repos/github/KazDragon/terminalpp/badge.svg?branch=master" style="pointer-events: none;">Coverage Status</object></a> <a href="https://www.codacy.com/app/KazDragon/terminalpp?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=KazDragon/terminalpp&amp;utm_campaign=Badge_Grade"><img src="https://api.codacy.com/project/badge/Grade/a2741e8f7abf49bc8b496fbf8b51b983" alt="Codacy Badge" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md13"></a>
Terminal++</h1>
<p>A C++ library for interacting with ANSI/VT100 terminal or terminal emulator displays.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Requirements</h1>
<p>Terminal++ requires a C++14 compiler and the following libraries:</p><ul>
<li>Boost (At least version 1.69.0)</li>
<li>libfmt (At least version 5.3)</li>
<li>(For testing only) Google Test</li>
</ul>
<h1><a class="anchor" id="autotoc_md15"></a>
Installation - CMake</h1>
<p>Terminal++ can be installed from source using CMake. This requires Boost, libfmt and any other dependencies to have been installed beforehand, using their own instructions, or for the call to <code>cmake --configure</code> to be adjusted appropriately (e.g. <code>-DBOOST_ROOT=...</code> or <code>-Dfmt_DIR=...</code>). If you do not wish to install into a system directory, and thus avoid the use of sudo, you can also pass <code>-DCMAKE_INSTALL_PREFIX=...</code> into the <code>cmake --configure</code> call. </p><pre class="fragment">git clone https://github.com/KazDragon/terminalpp.git &amp;&amp; cd terminalpp
mkdir build &amp;&amp; cd build
cmake --configure -DCMAKE_BUILD_TYPE=Release ..
cmake --build .
sudo cmake --install .
</pre><h1><a class="anchor" id="autotoc_md16"></a>
Installation - Conan</h1>
<p>You can also use <a href="https://conan.io/">the Conan Package Manager</a> to install Terminal++ and its dependencies.</p>
<p>See <a href="examples/tprint">the tprint example</a> for a minimalistic project that describes this setup.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Features / Roadmap</h1>
<ol type="1">
<li>[x] A utility for creating strings with embedded ANSI attributes<ul>
<li>[x] <a class="el" href="classterminalpp_1_1string.html" title="A class that represents strings of elements.">terminalpp::string</a></li>
<li>This will be immediately useful in line-oriented programs to construct and output streams of attributed (coloured, emboldened, underlined, etc.) text.</li>
</ul>
</li>
<li>[x] A utility for managing ANSI escape codes that are not bound to specific characters. For example, commands for moving the cursor, changing the screen's title, clearing the screen, etc.<ul>
<li>[x] <a class="el" href="classterminalpp_1_1terminal.html" title="A class that encapsulates a terminal.">terminalpp::terminal</a></li>
</ul>
</li>
<li>[x] Utilities for managing screens of attributed characters<ul>
<li>[x] <a class="el" href="classterminalpp_1_1canvas.html" title="A class representing a grid onto which elements can be painted.">terminalpp::canvas</a></li>
<li>[x] <a class="el" href="classterminalpp_1_1screen.html" title="A class that represents a screen for a terminal.">terminalpp::screen</a></li>
<li>This will be useful for those who wish to develop a more graphical or "curses-style" user interface.</li>
</ul>
</li>
<li>[ ] A database of terminal types and their associated behaviours<ul>
<li>With some kind of application-specific terminal type detection, this would make it possible to write apps that automatically adjust to the most appropriate protocols supported by the client.</li>
</ul>
</li>
</ol>
<p>A set of classes that implement a windowing user interface are currently being implemented in the <a href="https://github.com/KazDragon/munin">Munin project</a>.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Status</h1>
<p>Terminal++ is currently automatically tested using MSVC 2019 and GCC 7.5. For further information about the working status of the library, to report any bugs, or to make any feature requests, visit the <a href="https://github.com/KazDragon/terminalpp/issues">Issues page</a>. Feel free to discuss using Github Discussions!</p>
<h1><a class="anchor" id="autotoc_md19"></a>
The Basics</h1>
<p>The purpose of the library is to be able to allow the usage of ANSI escape codes to their fullest potential in order to create fully-featured text-based applications. The use cases for such software include interactive forms of command-line software, and even GUI-style applications over the internet using terminal emulators such as Xterm, PuTTY, or even some MUD clients (e.g Tintin++).</p>
<p>At its most fundamental level, Terminal++ is in the business of manipulating character elements on the screen, where each element is encoded as a glyph, which describes the character that is presented to the user, and a series of non-character graphical attributes. These are encapsulated in the following classes:</p>
<ul>
<li><a class="el" href="structterminalpp_1_1glyph.html" title="A structure that carries around the character attributes of an ANSI element.">terminalpp::glyph</a> - represents a character (which may be ASCII or any UTF-8 value up to U+FFFF) and its character set (by default, this is the US_ASCII character set).</li>
<li><a class="el" href="structterminalpp_1_1attribute.html" title="A structure that carries around the presentation attributes of an ANSI element.">terminalpp::attribute</a> - a collection of variables that describe the non-character graphical part of the output, such as the foreground and background colours, whether it is bold, underlined, and so on.</li>
</ul>
<p>These are combined into Terminal++'s fundamental type, <a class="el" href="structterminalpp_1_1element.html" title="A structure that represents the fundamental printable element of a terminal screen,...">terminalpp::element</a>.</p>
<p>The library's primary abstraction is the terminal class, which is a container for all the operations one might want to do on it. Because the terminal is unaware whether you are sending data to the console or over a network connection, each writing operation takes a function parameter that states the destination. You see this as the write_to_console function in the examples below. This also allows for other use cases where, for example, the continuation collects data from several operations in memory before transmitting the entire chunk in one go.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
Strings</h1>
<p>terminalpp::elements can be collected together using the <a class="el" href="classterminalpp_1_1string.html" title="A class that represents strings of elements.">terminalpp::string</a> class. It has several constructors for different uses. For example, one of the constructors takes a std::string and an attribute to apply to all those characters for when you want something like print out a single red error message. In addition, there are the user-defined literal suffixes _ts (terminal string) and _ets (encoded terminal string) to help construct more complicated strings</p>
<p><a href="examples/hello_world">Hello, World! project</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;terminalpp/terminal.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> write_to_console(terminalpp::bytes data)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; std::string{data.begin(), data.end()};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span>terminalpp::literals;</div>
<div class="line">    <a class="code" href="classterminalpp_1_1string.html">terminalpp::string</a> text = <span class="stringliteral">&quot;Hello, world!\n&quot;</span>_ts;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classterminalpp_1_1terminal.html">terminalpp::terminal</a> terminal;</div>
<div class="line">    terminal.<a class="code" href="classterminalpp_1_1terminal.html#af00e696c4b61caab4409cd140ee79a0e">write</a>(write_to_console) &lt;&lt; text;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Constructs a terminalpp::string, and then prints it to the terminal as, &quot;Hello, world!&quot;</span></div>
</div><!-- fragment --><p>By using _ets, you can also encode attributes within the text. For example:</p>
<p><a href="examples/encoded_hello_world">Encoded Hello, World! project</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;terminalpp/terminal.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> write_to_console(terminalpp::bytes data)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; std::string(data.begin(), data.end());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span>terminalpp::literals;</div>
<div class="line">    <a class="code" href="classterminalpp_1_1string.html">terminalpp::string</a> text = <span class="stringliteral">&quot;\\[1Hello, \\[2World! \\x\\U263A\n&quot;</span>_ets;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classterminalpp_1_1terminal.html">terminalpp::terminal</a> terminal;</div>
<div class="line">    terminal.<a class="code" href="classterminalpp_1_1terminal.html#af00e696c4b61caab4409cd140ee79a0e">write</a>(write_to_console) &lt;&lt; text;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This prints out "Hello, " in red text, then "World!" in green text, and then a smiley face in the default colour. See the Wiki for more information about the attribute encoding used and its possibilities. It is also possible to change the attributes for each element programatically.</p>
<div class="fragment"><div class="line"><a class="code" href="classterminalpp_1_1string.html">terminalpp::string</a> text = ...;</div>
<div class="line">text[0].attribute_.intensity_ = terminalpp::graphics::intensity::bold;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md21"></a>
Terminals</h1>
<p>At this point, you have everything you need for a standard command-line application that uses colour or other properties, such as you might see in the output of a CMake script or Google Test results, or even standard unix functions such as ls. But the terminal class allows for complete control over the terminal's appearance.</p>
<p><a href="examples/positioned_smiley">Positioned smiley project</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;terminalpp/terminal.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> write_to_console(terminalpp::bytes data)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; std::string{data.begin(), data.end()};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span>terminalpp::literals;</div>
<div class="line">    <a class="code" href="classterminalpp_1_1terminal.html">terminalpp::terminal</a> terminal;</div>
<div class="line"> </div>
<div class="line">    terminal.<a class="code" href="classterminalpp_1_1terminal.html#af00e696c4b61caab4409cd140ee79a0e">write</a>(write_to_console)</div>
<div class="line">        &lt;&lt; <a class="code" href="classterminalpp_1_1save__cursor__position.html">terminalpp::save_cursor_position</a>()</div>
<div class="line">        &lt;&lt; <a class="code" href="classterminalpp_1_1move__cursor.html">terminalpp::move_cursor</a>({0, 0})</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;\\U263A&quot;</span>_ets</div>
<div class="line">        &lt;&lt; <a class="code" href="classterminalpp_1_1restore__cursor__position.html">terminalpp::restore_cursor_position</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>This writes a smiley face in the (0, 0) position on the terminal &ndash; the top-left corner. The cursor position is unchanged. The terminal uses a 0-based co-ordinate system where point (0, 0) is the top-left corner, and the co-ordinates are in (x, y) order.</p>
<p>Note that it is necessary to output the results of the terminal operations. This is because terminalpp is datastream-agnostic: it doesn't know where the terminal you're writing to actually is. It could be standard out, it could be some named pipe, or it could be a network socket. This gives you the flexibility to use Terminal++ in any situation where there is some kind of terminal emulator on the other side of a stream, without imposing any kind of restrictions.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
Canvas and Screen</h1>
<p>For even finer control of the terminal, the <a class="el" href="classterminalpp_1_1canvas.html" title="A class representing a grid onto which elements can be painted.">terminalpp::canvas</a> class presents a grid of elements upon which you can "paint" the desired appearance of the terminal on a frame-by-frame by simply assigning to the appropriate co-ordinates:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classterminalpp_1_1canvas.html">terminalpp::canvas</a> canvas({80, 24});</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set the entire canvas to be the letter &#39;x&#39; on a shocking pink</span></div>
<div class="line">    <span class="comment">// background.  Because, why not?</span></div>
<div class="line">    <a class="code" href="structterminalpp_1_1element.html">terminalpp::element</a> element(<span class="charliteral">&#39;x&#39;</span>);</div>
<div class="line">    element.attribute_.background_colour_ = <a class="code" href="structterminalpp_1_1high__colour.html">terminalpp::high_colour</a>(5, 1, 2);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (terminalpp::coordinate_type y = 0; y &lt; canvas.size().height; ++y)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (terminalpp::coordinate_type x = 0; x &lt; canvas.size().width; ++x)</div>
<div class="line">        {</div>
<div class="line">            canvas[x][y] = element;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, assigning elements to the canvas wont actually cause any immediate effect. For that, you would need to index over the entire canvas and output it, element-by-element, to a terminal. But it's very wasteful to output the entire screen each time that a small part of it changes.</p>
<p>To control this, we present the <a class="el" href="classterminalpp_1_1screen.html" title="A class that represents a screen for a terminal.">terminalpp::screen</a> class, which represents a double-buffered approach to drawing the contents of a canvas. Its draw() member function will cause only the differences between the previously drawn canvas and the current canvas to be output, with efforts made to keep the output as small as possible. Note: it is assumed for the first canvas drawn, and for any canvas drawn after a change in output size, that everything has changed.</p>
<p><a href="examples/shocking_pink">Shocking pink project</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;terminalpp/terminal.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;terminalpp/canvas.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;terminalpp/screen.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> write_to_console(terminalpp::bytes data)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; std::string{data.begin(), data.end()};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classterminalpp_1_1terminal.html">terminalpp::terminal</a> terminal;</div>
<div class="line">    <a class="code" href="classterminalpp_1_1screen.html">terminalpp::screen</a> screen;</div>
<div class="line">    <a class="code" href="classterminalpp_1_1canvas.html">terminalpp::canvas</a> canvas({80, 24});</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set the entire canvas to be the letter &#39;x&#39; on a shocking pink</span></div>
<div class="line">    <span class="comment">// background.  Because, why not?</span></div>
<div class="line">    <a class="code" href="structterminalpp_1_1element.html">terminalpp::element</a> element(<span class="charliteral">&#39;x&#39;</span>);</div>
<div class="line">    element.attribute_.background_colour_ = <a class="code" href="structterminalpp_1_1high__colour.html">terminalpp::high_colour</a>(5, 1, 2);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (terminalpp::coordinate_type y = 0; y &lt; canvas.size().height_; ++y)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (terminalpp::coordinate_type x = 0; x &lt; canvas.size().width_; ++x)</div>
<div class="line">        {</div>
<div class="line">            canvas[x][y] = element;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    screen.<a class="code" href="classterminalpp_1_1screen.html#a056a356801a60ded3fb5a651e7f1fb85">draw</a>(terminal, canvas, write_to_console);</div>
<div class="line">    <span class="comment">// screen is now actually shocking pink.</span></div>
<div class="line"> </div>
<div class="line">    canvas[10][15].glyph_ = <span class="charliteral">&#39;y&#39;</span>;</div>
<div class="line">    canvas[10][15].attribute_.background_colour_ = terminalpp::graphics::colour::blue;</div>
<div class="line"> </div>
<div class="line">    screen.<a class="code" href="classterminalpp_1_1screen.html#a056a356801a60ded3fb5a651e7f1fb85">draw</a>(terminal, canvas, write_to_console);</div>
<div class="line">    <span class="comment">// screen is still shocking pink, but there is now a letter &#39;y&#39; with a</span></div>
<div class="line">    <span class="comment">// blue background at position (10, 15).</span></div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="aclassterminalpp_1_1string_html"><div class="ttname"><a href="classterminalpp_1_1string.html">terminalpp::string</a></div><div class="ttdoc">A class that represents strings of elements.</div><div class="ttdef"><b>Definition:</b> string.hpp:18</div></div>
<div class="ttc" id="aclassterminalpp_1_1screen_html_a056a356801a60ded3fb5a651e7f1fb85"><div class="ttname"><a href="classterminalpp_1_1screen.html#a056a356801a60ded3fb5a651e7f1fb85">terminalpp::screen::draw</a></div><div class="ttdeci">void draw(terminal &amp;term, canvas const &amp;cvs, WriteContinuation &amp;&amp;wc)</div><div class="ttdoc">Draws the current screen to the terminal.</div><div class="ttdef"><b>Definition:</b> screen.hpp:24</div></div>
<div class="ttc" id="astructterminalpp_1_1element_html"><div class="ttname"><a href="structterminalpp_1_1element.html">terminalpp::element</a></div><div class="ttdoc">A structure that represents the fundamental printable element of a terminal screen,...</div><div class="ttdef"><b>Definition:</b> element.hpp:18</div></div>
<div class="ttc" id="aclassterminalpp_1_1move__cursor_html"><div class="ttname"><a href="classterminalpp_1_1move__cursor.html">terminalpp::move_cursor</a></div><div class="ttdoc">A manipulator that moves the cursor to a new location.</div><div class="ttdef"><b>Definition:</b> terminal.hpp:105</div></div>
<div class="ttc" id="aclassterminalpp_1_1terminal_html"><div class="ttname"><a href="classterminalpp_1_1terminal.html">terminalpp::terminal</a></div><div class="ttdoc">A class that encapsulates a terminal.</div><div class="ttdef"><b>Definition:</b> terminal.hpp:28</div></div>
<div class="ttc" id="aclassterminalpp_1_1screen_html"><div class="ttname"><a href="classterminalpp_1_1screen.html">terminalpp::screen</a></div><div class="ttdoc">A class that represents a screen for a terminal.</div><div class="ttdef"><b>Definition:</b> screen.hpp:17</div></div>
<div class="ttc" id="astructterminalpp_1_1high__colour_html"><div class="ttname"><a href="structterminalpp_1_1high__colour.html">terminalpp::high_colour</a></div><div class="ttdoc">Structure representing the central 216 colours of a 256-colour palette, where each colour channel is ...</div><div class="ttdef"><b>Definition:</b> colour.hpp:90</div></div>
<div class="ttc" id="aclassterminalpp_1_1restore__cursor__position_html"><div class="ttname"><a href="classterminalpp_1_1restore__cursor__position.html">terminalpp::restore_cursor_position</a></div><div class="ttdoc">A manipulator that restores the cursor position.</div><div class="ttdef"><b>Definition:</b> terminal.hpp:739</div></div>
<div class="ttc" id="aclassterminalpp_1_1terminal_html_af00e696c4b61caab4409cd140ee79a0e"><div class="ttname"><a href="classterminalpp_1_1terminal.html#af00e696c4b61caab4409cd140ee79a0e">terminalpp::terminal::write</a></div><div class="ttdeci">detail::terminal_writer&lt; WriteContinuation &gt; write(WriteContinuation &amp;&amp;wc)</div><div class="ttdoc">Write to the terminal.</div><div class="ttdef"><b>Definition:</b> terminal.hpp:64</div></div>
<div class="ttc" id="aclassterminalpp_1_1save__cursor__position_html"><div class="ttname"><a href="classterminalpp_1_1save__cursor__position.html">terminalpp::save_cursor_position</a></div><div class="ttdoc">A manipulator that saves the cursor position.</div><div class="ttdef"><b>Definition:</b> terminal.hpp:712</div></div>
<div class="ttc" id="aclassterminalpp_1_1canvas_html"><div class="ttname"><a href="classterminalpp_1_1canvas.html">terminalpp::canvas</a></div><div class="ttdoc">A class representing a grid onto which elements can be painted.</div><div class="ttdef"><b>Definition:</b> canvas.hpp:17</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 27 2021 14:45:42 for Terminal++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
