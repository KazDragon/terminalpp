<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Terminal++: Terminal++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Terminal++
   &#160;<span id="projectnumber">3.1.0.3</span>
   </div>
   <div id="projectbrief">A C++ library for interacting with ANSI terminal windows</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Terminal++ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__home_runner_work_terminalpp_terminalpp_README"></a> <a href="https://kazdragon.github.io/terminalpp/"><img src="https://img.shields.io/badge/code-documented-brightgreen.svg?style=flat" alt="Documentation" style="pointer-events: none;" class="inline"/></a> <a href="https://en.wikipedia.org/wiki/MIT_License"><img src="https://img.shields.io/github/license/KazDragon/terminalpp.svg" alt="License" style="pointer-events: none;" class="inline"/></a> <a href="https://ci.appveyor.com/project/KazDragon/terminalpp/branch/master"><img src="https://ci.appveyor.com/api/projects/status/ywpx7m37e902hdoy/branch/master?svg=true" alt="MSVC Build status" class="inline"/></a> <a href="https://github.com/KazDragon/terminalpp/actions?query=event%3Apush"><img src="https://github.com/KazDragon/terminalpp/workflows/build/badge.svg" alt="Linux Build status" style="pointer-events: none;" class="inline"/></a> <a href="https://coveralls.io/github/KazDragon/terminalpp?branch=master"><img src="https://coveralls.io/repos/github/KazDragon/terminalpp/badge.svg?branch=master" alt="Coverage Status" style="pointer-events: none;" class="inline"/></a> <a href="https://www.codacy.com/gh/KazDragon/terminalpp/dashboard?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=KazDragon/terminalpp&amp;utm_campaign=Badge_Grade"><img src="https://app.codacy.com/project/badge/Grade/a2741e8f7abf49bc8b496fbf8b51b983" alt="Codacy Badge" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md14"></a>
Terminal++</h1>
<p>A C++ library for interacting with ANSI/VT100 terminal or terminal emulator displays.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Requirements</h1>
<p>Terminal++ requires a C++17 compiler and the following libraries:</p><ul>
<li>Boost (At least version 1.69.0)</li>
<li>libfmt (At least version 5.3)</li>
<li>(For testing only) Google Test</li>
</ul>
<h1><a class="anchor" id="autotoc_md16"></a>
Installation - CMake</h1>
<p>Terminal++ can be installed from source using CMake. This requires Boost, libfmt and any other dependencies to have been installed beforehand, using their own instructions, or for the call to <code>cmake --configure</code> to be adjusted appropriately (e.g. <code>-DBOOST_ROOT=...</code> or <code>-Dfmt_DIR=...</code>). If you do not wish to install into a system directory, and thus avoid the use of sudo, you can also pass <code>-DCMAKE_INSTALL_PREFIX=...</code> into the <code>cmake --configure</code> call. </p><pre class="fragment">git clone https://github.com/KazDragon/terminalpp.git &amp;&amp; cd terminalpp
mkdir build &amp;&amp; cd build
cmake --configure -DCMAKE_BUILD_TYPE=Release ..
cmake --build .
sudo cmake --install .
</pre> <h1><a class="anchor" id="autotoc_md17"></a>
Features / Roadmap</h1>
<ol type="1">
<li>[x] A utility for creating strings with embedded ANSI attributes<ul>
<li>[x] <a class="el" href="classterminalpp_1_1string.html" title="A class that represents strings of elements.">terminalpp::string</a></li>
<li>This will be immediately useful in line-oriented programs to construct and output streams of attributed (coloured, emboldened, underlined, etc.) text.</li>
</ul>
</li>
<li>[x] A utility for managing ANSI escape codes that are not bound to specific characters. For example, commands for moving the cursor, changing the screen's title, clearing the screen, etc.<ul>
<li>[x] <a class="el" href="classterminalpp_1_1terminal.html" title="A class that encapsulates a terminal.">terminalpp::terminal</a></li>
</ul>
</li>
<li>[x] Utilities for managing screens of attributed characters<ul>
<li>[x] <a class="el" href="classterminalpp_1_1canvas.html" title="A class representing a grid onto which elements can be painted.">terminalpp::canvas</a></li>
<li>[x] <a class="el" href="classterminalpp_1_1screen.html" title="A class that represents a screen for a terminal.">terminalpp::screen</a></li>
<li>This will be useful for those who wish to develop a more graphical or "curses-style" user interface.</li>
</ul>
</li>
<li>[ ] A database of terminal types and their associated behaviours<ul>
<li>With some kind of application-specific terminal type detection, this would make it possible to write apps that automatically adjust to the most appropriate protocols supported by the client.</li>
</ul>
</li>
</ol>
<p>A set of classes that implement a windowing user interface are currently being implemented in the <a href="https://github.com/KazDragon/munin">Munin project</a>.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Status</h1>
<p>Terminal++ is currently automatically tested using MSVC 2019 and GCC 9.4. For further information about the working status of the library, to report any bugs, or to make any feature requests, visit the <a href="https://github.com/KazDragon/terminalpp/issues">Issues page</a>. Feel free to discuss using Github Discussions!</p>
<h1><a class="anchor" id="autotoc_md19"></a>
The Basics</h1>
<p>The purpose of the library is to be able to allow the usage of ANSI escape codes to their fullest potential in order to create fully-featured text-based applications. The use cases for such software range from interactive forms of command-line software up to GUI-style applications over the internet using terminal emulators such as Xterm, PuTTY, or even some MUD clients (e.g Tintin++).</p>
<p>At its most fundamental level, Terminal++ is in the business of manipulating character elements on the screen, where each element is encoded as a glyph, which describes the character that is presented to the user, and a series of non-character graphical attributes. These are encapsulated in the following classes:</p>
<ul>
<li><a class="el" href="structterminalpp_1_1glyph.html" title="A structure that carries around the character attributes of an ANSI element.">terminalpp::glyph</a> - represents a character (which may be ASCII or any UTF-8 value up to U+FFFF) and its character set (by default, this is the US_ASCII character set).</li>
<li><a class="el" href="structterminalpp_1_1attribute.html" title="A structure that carries around the presentation attributes of an ANSI element.">terminalpp::attribute</a> - a collection of variables that describe the non-character graphical part of the output, such as the foreground and background colours, whether it is bold, underlined, and so on.</li>
</ul>
<p>These are combined into Terminal++'s fundamental type, <a class="el" href="structterminalpp_1_1element.html" title="A structure that represents the fundamental printable element of a terminal screen,...">terminalpp::element</a>.</p>
<p>The library's primary abstraction is the terminal class, which is a container for all the operations one might want to do on it. Because the terminal does not know whether you are sending data to the console, over a network connection or into a file, it uses a type-erased "channel" concept onto which these operations are mapped. This concept aligns closely with telnetpp::session, serverpp::tcp_socket and consolepp::console in the Telnet++, Server++ and Console++ libraries, respectively, for easier integration. Terminal++ also provides stdout_channel, which can serve for programs who do not require asynchronous input. This use of this is demonstrated in the examples below.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
Strings</h1>
<p>terminalpp::elements can be collected together using the <a class="el" href="classterminalpp_1_1string.html" title="A class that represents strings of elements.">terminalpp::string</a> class. It has several constructors for different uses. For example, one of the constructors takes a std::string and an attribute to apply to all those characters for when you want something like print out a single red error message. In addition, there are the user-defined literal suffixes _ts (terminal string) and _ets (encoded terminal string) to help construct more complex strings.</p>
<p><a href="examples/hello_world">Hello, World! project</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;terminalpp/terminal.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;terminalpp/stdout_channel.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span>terminalpp::literals;</div>
<div class="line">    <a class="code" href="classterminalpp_1_1string.html">terminalpp::string</a> text = <span class="stringliteral">&quot;Hello, world!\n&quot;</span>_ts;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classterminalpp_1_1stdout__channel.html">terminalpp::stdout_channel</a> channel;</div>
<div class="line">    <a class="code" href="classterminalpp_1_1terminal.html">terminalpp::terminal</a> terminal{channel};</div>
<div class="line">    terminal &lt;&lt; text;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Constructs a terminalpp::string, and then prints it to the terminal as, &quot;Hello, world!&quot;</span></div>
<div class="ttc" id="aclassterminalpp_1_1stdout__channel_html"><div class="ttname"><a href="classterminalpp_1_1stdout__channel.html">terminalpp::stdout_channel</a></div><div class="ttdoc">A class that models the terminal's channel concept, providing output to stdout.</div><div class="ttdef"><b>Definition:</b> stdout_channel.hpp:14</div></div>
<div class="ttc" id="aclassterminalpp_1_1string_html"><div class="ttname"><a href="classterminalpp_1_1string.html">terminalpp::string</a></div><div class="ttdoc">A class that represents strings of elements.</div><div class="ttdef"><b>Definition:</b> string.hpp:32</div></div>
<div class="ttc" id="aclassterminalpp_1_1terminal_html"><div class="ttname"><a href="classterminalpp_1_1terminal.html">terminalpp::terminal</a></div><div class="ttdoc">A class that encapsulates a terminal.</div><div class="ttdef"><b>Definition:</b> terminal.hpp:22</div></div>
</div><!-- fragment --><p>By using _ets, you can also encode attributes within the text. For example:</p>
<p><a href="examples/encoded_hello_world">Encoded Hello, World! project</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;terminalpp/terminal.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;terminalpp/stdout_channel.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span>terminalpp::literals;</div>
<div class="line">    <a class="code" href="classterminalpp_1_1string.html">terminalpp::string</a> text = <span class="stringliteral">&quot;\\[1Hello, \\[2World! \\x\\U263A\n&quot;</span>_ets;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classterminalpp_1_1stdout__channel.html">terminalpp::stdout_channel</a> channel;</div>
<div class="line">    <a class="code" href="classterminalpp_1_1terminal.html">terminalpp::terminal</a> terminal{channel};</div>
<div class="line">    terminal &lt;&lt; text;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This prints out "Hello, " in red text, then "World!" in green text, and then a smiley face in the default colour. See the Wiki for more information about the attribute encoding used and its possibilities. It is also possible to change the attributes for each element programatically.</p>
<div class="fragment"><div class="line"><a class="code" href="classterminalpp_1_1string.html">terminalpp::string</a> text = ...;</div>
<div class="line">text[0].attribute_.intensity_ = terminalpp::graphics::intensity::bold;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md21"></a>
Terminals</h1>
<p>At this point, you have everything you need for a standard command-line application that uses colour or other properties, such as you might see in the output of a CMake script or Google Test results, or even standard unix functions such as ls. But the terminal class allows for complete control over the terminal's appearance.</p>
<p><a href="examples/positioned_smiley">Positioned smiley project</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;terminalpp/terminal.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;terminalpp/stdout_channel.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span>terminalpp::literals;</div>
<div class="line">    <a class="code" href="classterminalpp_1_1stdout__channel.html">terminalpp::stdout_channel</a> channel;</div>
<div class="line">    <a class="code" href="classterminalpp_1_1terminal.html">terminalpp::terminal</a> terminal{channel};</div>
<div class="line"> </div>
<div class="line">    terminal</div>
<div class="line">        &lt;&lt; <a class="code" href="classterminalpp_1_1save__cursor__position.html">terminalpp::save_cursor_position</a>()</div>
<div class="line">        &lt;&lt; <a class="code" href="classterminalpp_1_1move__cursor.html">terminalpp::move_cursor</a>({0, 0})</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;\\U263A&quot;</span>_ets</div>
<div class="line">        &lt;&lt; <a class="code" href="classterminalpp_1_1restore__cursor__position.html">terminalpp::restore_cursor_position</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclassterminalpp_1_1move__cursor_html"><div class="ttname"><a href="classterminalpp_1_1move__cursor.html">terminalpp::move_cursor</a></div><div class="ttdoc">A manipulator that outputs ANSI protocol bytes to move the cursor to the specified location.</div><div class="ttdef"><b>Definition:</b> terminal.hpp:286</div></div>
<div class="ttc" id="aclassterminalpp_1_1restore__cursor__position_html"><div class="ttname"><a href="classterminalpp_1_1restore__cursor__position.html">terminalpp::restore_cursor_position</a></div><div class="ttdoc">A manipulator that restores the cursor position.</div><div class="ttdef"><b>Definition:</b> terminal.hpp:360</div></div>
<div class="ttc" id="aclassterminalpp_1_1save__cursor__position_html"><div class="ttname"><a href="classterminalpp_1_1save__cursor__position.html">terminalpp::save_cursor_position</a></div><div class="ttdoc">A manipulator that saves the cursor position.</div><div class="ttdef"><b>Definition:</b> terminal.hpp:345</div></div>
</div><!-- fragment --><p>This writes a smiley face in the (0, 0) position on the terminal &ndash; the top-left corner. The cursor position is unchanged. The terminal uses a 0-based co-ordinate system where point (0, 0) is the top-left corner, and the co-ordinates are in (x, y) order.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
Canvas and Screen</h1>
<p>For even finer control of the terminal, the <a class="el" href="classterminalpp_1_1canvas.html" title="A class representing a grid onto which elements can be painted.">terminalpp::canvas</a> class presents a grid of elements upon which you can "paint" the desired appearance of the terminal on a frame-by-frame by simply assigning to the appropriate co-ordinates:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classterminalpp_1_1canvas.html">terminalpp::canvas</a> canvas({80, 24});</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set the entire canvas to be the letter &#39;x&#39; on a shocking pink</span></div>
<div class="line">    <span class="comment">// background.  Because, why not?</span></div>
<div class="line">    <a class="code" href="structterminalpp_1_1element.html">terminalpp::element</a> element(<span class="charliteral">&#39;x&#39;</span>);</div>
<div class="line">    element.attribute_.background_colour_ = <a class="code" href="structterminalpp_1_1high__colour.html">terminalpp::high_colour</a>(5, 1, 2);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (terminalpp::coordinate_type y = 0; y &lt; canvas.size().height; ++y)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (terminalpp::coordinate_type x = 0; x &lt; canvas.size().width; ++x)</div>
<div class="line">        {</div>
<div class="line">            canvas[x][y] = element;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassterminalpp_1_1canvas_html"><div class="ttname"><a href="classterminalpp_1_1canvas.html">terminalpp::canvas</a></div><div class="ttdoc">A class representing a grid onto which elements can be painted.</div><div class="ttdef"><b>Definition:</b> canvas.hpp:19</div></div>
<div class="ttc" id="astructterminalpp_1_1element_html"><div class="ttname"><a href="structterminalpp_1_1element.html">terminalpp::element</a></div><div class="ttdoc">A structure that represents the fundamental printable element of a terminal screen,...</div><div class="ttdef"><b>Definition:</b> element.hpp:23</div></div>
<div class="ttc" id="astructterminalpp_1_1high__colour_html"><div class="ttname"><a href="structterminalpp_1_1high__colour.html">terminalpp::high_colour</a></div><div class="ttdoc">Structure representing the central 216 colours of a 256-colour palette, where each colour channel is ...</div><div class="ttdef"><b>Definition:</b> colour.hpp:83</div></div>
</div><!-- fragment --><p>Now, assigning elements to the canvas wont actually cause any immediate effect. For that, you would need to index over the entire canvas and output it, element-by-element, to a terminal. But it's very wasteful to output the entire screen each time that a small part of it changes.</p>
<p>To control this, we present the <a class="el" href="classterminalpp_1_1screen.html" title="A class that represents a screen for a terminal.">terminalpp::screen</a> class, which represents a double-buffered approach to drawing the contents of a canvas. Its draw() member function will cause only the differences between the previously drawn canvas and the current canvas to be output, with efforts made to keep the output as small as possible. Note: it is assumed for the first canvas drawn, and for any canvas drawn after a change in output size, that everything has changed.</p>
<p><a href="examples/shocking_pink">Shocking pink project</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;terminalpp/terminal.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;terminalpp/canvas.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;terminalpp/screen.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;terminalpp/stdout_channel.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classterminalpp_1_1stdout__channel.html">terminalpp::stdout_channel</a> channel;</div>
<div class="line">    <a class="code" href="classterminalpp_1_1terminal.html">terminalpp::terminal</a> terminal{channel};</div>
<div class="line">    <a class="code" href="classterminalpp_1_1screen.html">terminalpp::screen</a> screen{terminal};</div>
<div class="line">    <a class="code" href="classterminalpp_1_1canvas.html">terminalpp::canvas</a> canvas({80, 24});</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set the entire canvas to be the letter &#39;x&#39; on a shocking pink</span></div>
<div class="line">    <span class="comment">// background.  Because, why not?</span></div>
<div class="line">    <a class="code" href="structterminalpp_1_1element.html">terminalpp::element</a> element(<span class="charliteral">&#39;x&#39;</span>);</div>
<div class="line">    element.attribute_.background_colour_ = <a class="code" href="structterminalpp_1_1high__colour.html">terminalpp::high_colour</a>(5, 1, 2);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (terminalpp::coordinate_type y = 0; y &lt; canvas.size().height_; ++y)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (terminalpp::coordinate_type x = 0; x &lt; canvas.size().width_; ++x)</div>
<div class="line">        {</div>
<div class="line">            canvas[x][y] = element;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    screen.draw(canvas);</div>
<div class="line">    <span class="comment">// screen is now actually shocking pink.</span></div>
<div class="line"> </div>
<div class="line">    canvas[10][15].glyph_ = <span class="charliteral">&#39;y&#39;</span>;</div>
<div class="line">    canvas[10][15].attribute_.background_colour_ = terminalpp::graphics::colour::blue;</div>
<div class="line"> </div>
<div class="line">    screen.draw(canvas);</div>
<div class="line">    <span class="comment">// screen is still shocking pink, but there is now a letter &#39;y&#39; with a</span></div>
<div class="line">    <span class="comment">// blue background at position (10, 15).</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassterminalpp_1_1screen_html"><div class="ttname"><a href="classterminalpp_1_1screen.html">terminalpp::screen</a></div><div class="ttdoc">A class that represents a screen for a terminal.</div><div class="ttdef"><b>Definition:</b> screen.hpp:16</div></div>
</div><!-- fragment --><p>It is also possible to read from a terminal. Standard C++ does not provide a way of reading from standard input asynchronously, so this requires operating system support. The <a href="https://github.com/KazDragon/consolepp">Console++ library</a> library implements this for certain platforms. Its consolepp::console class models the channel concept, so it fits right into a terminal. Using the terminal to read bytes from the console will convert the input into a sequence of ANSI protocol bytes into a series of tokens that can be inspected for regular text, control sequences (including function keys, arrow keys, etc.) and even mouse operations if that is set in the terminal's behaviour.</p>
<p><a href="examples/wait_for_mouse_click">wait_for_mouse_click project</a> </p><div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> boost::asio::io_context io_context;</div>
<div class="line"><span class="keyword">static</span> consolepp::console console{io_context};</div>
<div class="line"><span class="keyword">static</span> <a class="code" href="classterminalpp_1_1terminal.html">terminalpp::terminal</a> terminal{</div>
<div class="line">    console,</div>
<div class="line">    [] {</div>
<div class="line">        <a class="code" href="structterminalpp_1_1behaviour.html">terminalpp::behaviour</a> behaviour;</div>
<div class="line">        behaviour.supports_basic_mouse_tracking = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">return</span> behaviour;</div>
<div class="line">    }()</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    terminal &lt;&lt; <a class="code" href="classterminalpp_1_1save__cursor__position.html">terminalpp::save_cursor_position</a>()</div>
<div class="line">             &lt;&lt; <a class="code" href="classterminalpp_1_1use__alternate__screen__buffer.html">terminalpp::use_alternate_screen_buffer</a>()</div>
<div class="line">             &lt;&lt; <a class="code" href="classterminalpp_1_1enable__mouse.html">terminalpp::enable_mouse</a>()</div>
<div class="line">             &lt;&lt; <a class="code" href="classterminalpp_1_1erase__display.html">terminalpp::erase_display</a>()</div>
<div class="line">             &lt;&lt; <a class="code" href="classterminalpp_1_1move__cursor.html">terminalpp::move_cursor</a>({0, 0})</div>
<div class="line">             &lt;&lt; <span class="stringliteral">&quot;Click with a mouse button to exit!\n&quot;</span>;</div>
<div class="line">        </div>
<div class="line">    schedule_async_read();</div>
<div class="line">    io_context.run();</div>
<div class="line"> </div>
<div class="line">    terminal &lt;&lt; <a class="code" href="classterminalpp_1_1disable__mouse.html">terminalpp::disable_mouse</a>()</div>
<div class="line">             &lt;&lt; <a class="code" href="classterminalpp_1_1use__normal__screen__buffer.html">terminalpp::use_normal_screen_buffer</a>()</div>
<div class="line">             &lt;&lt; <a class="code" href="classterminalpp_1_1restore__cursor__position.html">terminalpp::restore_cursor_position</a>()</div>
<div class="line">             &lt;&lt; fmt::format(<span class="stringliteral">&quot;mouse clicked at ({},{})\n&quot;</span>, mouse_position.x_, mouse_position.y_);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> handle_token(terminalpp::token <span class="keyword">const</span> &amp;token);</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> schedule_async_read()</div>
<div class="line">{</div>
<div class="line">    terminal.async_read(</div>
<div class="line">        [](terminalpp::tokens tokens) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp;token : tokens) {</div>
<div class="line">                handle_token(token);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            schedule_async_read();</div>
<div class="line">        });</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="ttc" id="aclassterminalpp_1_1disable__mouse_html"><div class="ttname"><a href="classterminalpp_1_1disable__mouse.html">terminalpp::disable_mouse</a></div><div class="ttdoc">A manipulator that disables mouse clicks according to the terminal behaviour.</div><div class="ttdef"><b>Definition:</b> terminal.hpp:486</div></div>
<div class="ttc" id="aclassterminalpp_1_1enable__mouse_html"><div class="ttname"><a href="classterminalpp_1_1enable__mouse.html">terminalpp::enable_mouse</a></div><div class="ttdoc">A manipulator that enables mouse clicks according to the terminal behaviour.</div><div class="ttdef"><b>Definition:</b> terminal.hpp:470</div></div>
<div class="ttc" id="aclassterminalpp_1_1erase__display_html"><div class="ttname"><a href="classterminalpp_1_1erase__display.html">terminalpp::erase_display</a></div><div class="ttdoc">A manipulator that erases the entire display.</div><div class="ttdef"><b>Definition:</b> terminal.hpp:375</div></div>
<div class="ttc" id="aclassterminalpp_1_1use__alternate__screen__buffer_html"><div class="ttname"><a href="classterminalpp_1_1use__alternate__screen__buffer.html">terminalpp::use_alternate_screen_buffer</a></div><div class="ttdoc">A manipulator that enables the use of the alternate screen buffer.</div><div class="ttdef"><b>Definition:</b> terminal.hpp:539</div></div>
<div class="ttc" id="aclassterminalpp_1_1use__normal__screen__buffer_html"><div class="ttname"><a href="classterminalpp_1_1use__normal__screen__buffer.html">terminalpp::use_normal_screen_buffer</a></div><div class="ttdoc">A manipulator that enables the use of the normal screen buffer.</div><div class="ttdef"><b>Definition:</b> terminal.hpp:524</div></div>
<div class="ttc" id="astructterminalpp_1_1behaviour_html"><div class="ttname"><a href="structterminalpp_1_1behaviour.html">terminalpp::behaviour</a></div><div class="ttdoc">A set of flags that determine how a terminal should behave over a datastream.</div><div class="ttdef"><b>Definition:</b> behaviour.hpp:12</div></div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 30 2024 10:52:04 for Terminal++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
